return function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Bag = require(ReplicatedStorage.Modules.Bag)

    describe("Bag", function()
		it("Should create a new bag", function()
			local bag = Bag.new()
			expect(bag).to.be.ok()
			expect(bag.className).to.equal("Bag")
		end)
		it("Should destroy the bag", function()
			local bag = Bag.new()
			bag:Destroy()
			expect(bag._Destroyed).to.be.equal(true)
		end)
		it("Should add an item to the bag", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			bag:Add(part)
			expect(#bag._Items).to.be.equal(1)
		end)
		it("Should not add duplicate items", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			bag:Add(part)
			bag:Add(part)
			expect(#bag._Items).to.be.equal(1)
		end)
		it("Should return the added item", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			local returned = bag:Add(part)
			expect(returned).to.equal(part)
		end)
		it("Should remove an item from the bag", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			bag:Add(part)
			local removed = bag:Remove(part)
			expect(#bag._Items).to.be.equal(0)
			expect(removed).to.equal(true)
		end)
		it("Should return false when removing non-existent item", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			local removed = bag:Remove(part)
			expect(removed).to.equal(false)
		end)
		it("Should invoke dispose method when removing", function()
			local bag = Bag.new()
			local disposed = false
			bag:Add(function()
				disposed = true
			end)
			bag:Remove(bag._Items[1].Item)
			expect(disposed).to.equal(true)
		end)
		it("Should dispose of the bag", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			bag:Add(part)
			expect(#bag._Items).to.be.equal(1)
			bag:Dispose()
			expect(#bag._Items).to.be.equal(0)
		end)
		it("Should dispose items in LIFO order", function()
			local bag = Bag.new()
			local order = {}
			bag:Add(function() table.insert(order, 1) end)
			bag:Add(function() table.insert(order, 2) end)
			bag:Add(function() table.insert(order, 3) end)
			bag:Dispose()
			expect(order[1]).to.equal(3)
			expect(order[2]).to.equal(2)
			expect(order[3]).to.equal(1)
		end)
		it("Should dispose of the bag and all items in it", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			local connection = part.Touched:Connect(function() end)
			bag:Add(part)
			bag:Add(connection)
			expect(#bag._Items).to.be.equal(2)
			bag:Dispose()
			expect(#bag._Items).to.be.equal(0)
		end)
		it("Should dispose of the bag and all items in it when destroyed", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			local connection = part.Touched:Connect(function() end)
			bag:Add(part)
			bag:Add(connection)
			expect(#bag._Items).to.be.equal(2)
			bag:Destroy()
			expect(bag._Items).to.equal(nil)
		end)
		it("Should handle Instance dispose method", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			part.Parent = workspace
			bag:Add(part)
			bag:Dispose()
			expect(part.Parent).to.equal(nil)
		end)
		it("Should handle RBXScriptConnection dispose method", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			local connection = part.Touched:Connect(function() end)
			bag:Add(connection)
			bag:Dispose()
			expect(connection.Connected).to.equal(false)
		end)
		it("Should handle function dispose method", function()
			local bag = Bag.new()
			local called = false
			bag:Add(function() called = true end)
			bag:Dispose()
			expect(called).to.equal(true)
		end)
		it("Should handle thread dispose method", function()
			local bag = Bag.new()
			local thread = task.spawn(function()
				while true do
					task.wait()
				end
			end)
			bag:Add(thread)
			bag:Dispose()
			expect(coroutine.status(thread)).to.equal("dead")
		end)
		it("Should handle table with Destroy method", function()
			local bag = Bag.new()
			local destroyed = false
			local obj = {
				Destroy = function(self)
					destroyed = true
				end
			}
			bag:Add(obj)
			bag:Dispose()
			expect(destroyed).to.equal(true)
		end)
		it("Should handle table with destroy method", function()
			local bag = Bag.new()
			local destroyed = false
			local obj = {
				destroy = function(self)
					destroyed = true
				end
			}
			bag:Add(obj)
			bag:Dispose()
			expect(destroyed).to.equal(true)
		end)
		it("Should handle table with Disconnect method", function()
			local bag = Bag.new()
			local disconnected = false
			local obj = {
				Disconnect = function(self)
					disconnected = true
				end
			}
			bag:Add(obj)
			bag:Dispose()
			expect(disconnected).to.equal(true)
		end)
		it("Should handle table with disconnect method", function()
			local bag = Bag.new()
			local disconnected = false
			local obj = {
				disconnect = function(self)
					disconnected = true
				end
			}
			bag:Add(obj)
			bag:Dispose()
			expect(disconnected).to.equal(true)
		end)
		it("Should dispose with custom dispose method", function()
			local bag = Bag.new()
			local fired = false
			local table = {
				custom = function(self)
					fired = true
				end
			}
			bag:Add(table, "custom")
			bag:Destroy()
			expect(fired).to.be.equal(true)
		end)
		it("Should maintain tracking after swap-and-pop remove", function()
			local bag = Bag.new()
			local item1 = Instance.new("Part")
			local item2 = Instance.new("Part")
			local item3 = Instance.new("Part")

			bag:Add(item1)
			bag:Add(item2)
			bag:Add(item3)

			bag:Remove(item2)

			expect(#bag._Items).to.equal(2)
			expect(bag._Tracked[item1]).to.be.ok()
			expect(bag._Tracked[item2]).never.to.be.ok()
			expect(bag._Tracked[item3]).to.be.ok()
		end)
		it("Should handle removing last item correctly", function()
			local bag = Bag.new()
			local item1 = Instance.new("Part")
			local item2 = Instance.new("Part")

			bag:Add(item1)
			bag:Add(item2)
			bag:Remove(item2)

			expect(#bag._Items).to.equal(1)
			expect(bag._Items[1].Item).to.equal(item1)
		end)
		it("Should destroy the bag when the instance it's attached to is destroyed", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			part.Parent = workspace
			bag:Attach(part)

			local disposed = false
			bag:Add(function()
				disposed = true
			end)

			expect(#bag._Items).to.be.equal(1)
			part:Destroy()

			task.wait()
			expect(disposed).to.be.equal(true)
			expect(bag._Destroyed).to.equal(true)
		end)
		it("Should detach from a previously attached instance when attaching to a new one", function()
			local bag = Bag.new()
			local part1 = Instance.new("Part")
			part1.Parent = workspace
			local part2 = Instance.new("Part")
			part2.Parent = workspace

			bag:Attach(part1)

			local disposed = false
			bag:Add(function()
				disposed = true
			end)

			bag:Attach(part2)
			part1:Destroy()

			task.wait()
			expect(disposed).to.be.equal(false)
			part2:Destroy()
			task.wait()
			expect(disposed).to.be.equal(true)
		end)
		it("Should not error when destroying an already destroyed bag", function()
			local bag = Bag.new()
			bag:Destroy()
			expect(function()
				bag:Destroy()
			end).to.never.throw()
		end)
		it("Should not error when disposing an already destroyed bag", function()
			local bag = Bag.new()
			bag:Destroy()
			expect(function()
				bag:Dispose()
			end).to.throw()
		end)
		it("Should error when attaching to a non-instance", function()
			local bag = Bag.new()
			expect(function()
				bag:Attach("not an instance")
			end).to.throw()
		end)
		it("Should error when attaching to an instance not in the DataModel", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			expect(function()
				bag:Attach(part)
			end).to.throw()
		end)
		it("Should error when adding to a destroyed bag", function()
			local bag = Bag.new()
			bag:Destroy()
			expect(function()
				bag:Add(Instance.new("Part"))
			end).to.throw()
		end)
		it("Should error when removing from a destroyed bag", function()
			local bag = Bag.new()
			bag:Destroy()
			expect(function()
				bag:Remove(Instance.new("Part"))
			end).to.throw()
		end)
		it("Should error when attaching to a destroyed bag", function()
			local bag = Bag.new()
			local part = Instance.new("Part")
			part.Parent = workspace
			bag:Destroy()
			expect(function()
				bag:Attach(part)
			end).to.throw()
		end)
		it("Should validate custom dispose method is a string", function()
			local bag = Bag.new()
			expect(function()
				bag:Add({}, 123)
			end).to.throw()
		end)
		it("Should clear all references on destroy", function()
			local bag = Bag.new()
			bag:Add(Instance.new("Part"))
			bag:Destroy()
			expect(bag._Items).to.equal(nil)
			expect(bag._Tracked).to.equal(nil)
			expect(bag._DestroyingConnection).to.equal(nil)
		end)
    end)
end
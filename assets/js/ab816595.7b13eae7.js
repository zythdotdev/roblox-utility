"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[866],{18388:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new `Bag` object","params":[],"returns":[{"desc":"The `Bag` object","lua_type":"Bag"}],"function_type":"static","source":{"line":112,"path":"src/Modules/Bag/init.lua"}},{"name":"destroy","desc":"Deconstructs the `Bag` object","params":[{"name":"self","desc":"","lua_type":"Bag"}],"returns":[],"function_type":"static","source":{"line":123,"path":"src/Modules/Bag/init.lua"}},{"name":"add","desc":"Adds an `Item` reference to the `Bag`. When the bags contents are disposed of or the bag is destroyed the item\'s dispose method will be invoked and the reference\\nto the item will be removed from the bag.\\n\\n| Type | Dispose Method |\\n| ---- | ------- |\\n| `Instance` | `object:Destroy()` |\\n| `RBXScriptConnection` | `object:Disconnect()` |\\n| `function` | `object()` |\\n| `thread` | `task.cancel(object)` |\\n| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |\\n| `table` with `disposeMethod` | `object:disposeMethod()` |\\n\\n:::caution\\nAn error will be thrown if a dispose method cannot be found for the object type that was added to the `Bag`\\n:::\\n\\n```lua\\n-- Adding a function to the `Bag` and then disposing of the bags contents will invoke the function\\nBag:add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:dispose()\\n\\n-- Adding a table to the `Bag` and then disposing of the bags contents will invoke the tables `destroy`, \'disconnect\' or their PascalCased counterpart methods if they exist\\nlocal class = {\\n\\tdestroy = function(self)\\n\\t\\tprint(\\"Disposed!\\")\\n\\tend\\n}\\nBag:add(class)\\nBag:dispose()\\n\\n-- Adding a Roblox `Instance` to the `Bag` and then disposing of the bags contents will also destroy the `Instance`\\nlocal part = Instance.new(\\"Part\\")\\nBag:add(part)\\nBag:dispose()\\n\\n-- You can define a custom dispose method on a table and pass it in as the second argument. This will be invoked when the bags contents are disposed of\\nlocal class = {\\n\\tcustomDisposeMethod = function(self)\\n\\t\\tprint(\\"Disposed!\\")\\n\\tend\\n}\\nBag:add(class, \\"customDisposeMethod\\")\\nBag:dispose()\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"item","desc":"Item to retain a reference to","lua_type":"Item"},{"name":"disposeMethod","desc":"An optional dispose method name to invoke on the item when the bags disposed or destroyed","lua_type":"string?"}],"returns":[{"desc":"The item that was passed in","lua_type":"item Item"}],"function_type":"static","source":{"line":184,"path":"src/Modules/Bag/init.lua"}},{"name":"remove","desc":"Removes the item reference from the `Bag` and invokes its dispose method. If the item was found and removed, `true` is returned, otherwise `false` is returned\\n\\n```lua\\nlocal func = Bag:add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:remove(func) -- \\"Disposed!\\" will be printed\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"item","desc":"Item to remove from the bag","lua_type":"Item"}],"returns":[{"desc":"Whether or not the item was removed","lua_type":"boolean"}],"function_type":"static","source":{"line":202,"path":"src/Modules/Bag/init.lua"}},{"name":"dispose","desc":"Disposes of all item references in the `Bag`. This is the same as invoking `remove` on each object added to the `Bag`. The\\nordering in which the objects are disposed of isn\'t guaranteed to match the order in which they were added\\n\\n```lua\\nlocal part = Instance.new(\\"Part\\")\\nlocal connection = part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend)\\nBag:add(part)\\nBag:add(connection)\\nBag:dispose() -- \'part\' is destroyed and \'connection\' is disconnected\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"}],"returns":[],"function_type":"static","source":{"line":228,"path":"src/Modules/Bag/init.lua"}},{"name":"attach","desc":"Attaches the `Bag` object to a Roblox `Instance`. Invoking this method will detach the `Bag` from any previously attached `Instance`. When\\nthe attached instance is removed from the game (its parent or ancestor\'s parent is set to `nil`), the Bag will automatically destroy\\nitself. It\'s important that any references to the bag are still released when it\'s no longer being used\\n\\n:::caution\\nAn error will be thrown if `instance` is not a descendant of the game\'s DataModel\\n:::","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"static","source":{"line":246,"path":"src/Modules/Bag/init.lua"}}],"properties":[{"name":"className","desc":"Static property that defines the class name `Bag`","lua_type":"string","tags":["Static"],"source":{"line":85,"path":"src/Modules/Bag/init.lua"}}],"types":[{"name":"Self","desc":"","lua_type":"Bag","source":{"line":33,"path":"src/Modules/Bag/init.lua"}},{"name":"Instance","desc":"An item that can be added to the Bag","lua_type":"Instance","source":{"line":41,"path":"src/Modules/Bag/init.lua"}}],"name":"Bag","desc":"A `Bag` is used to retain object references that need to be disposed of at some point in the future. When the bag is destroyed, all\\nobjects within the bag are also disposed of. This class is inspired by Trove, Maid and Janitor but implements a camelCased API and has\\na few minor differences in how it handles disposing objects\\n\\n```lua\\nlocal bag = Bag.new()\\nlocal part = Instance.new(\\"Part\\")\\nbag:add(part)\\nbag:add(part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend))\\nbag:destroy() -- \'part\' is destroyed and the \'Touched\' connection is disconnected\\n```","source":{"line":103,"path":"src/Modules/Bag/init.lua"}}')}}]);
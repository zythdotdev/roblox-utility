"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[120],{32100:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new `Event` object","params":[],"returns":[{"desc":"The `Event` object","lua_type":"Event"}],"function_type":"static","tags":["Static"],"source":{"line":188,"path":"src/Modules/Event/init.lua"}},{"name":"Destroy","desc":"Deconstructs the `Event` object and disconnects/destroys all connections","params":[{"name":"self","desc":"","lua_type":"Event"}],"returns":[],"function_type":"static","source":{"line":199,"path":"src/Modules/Event/init.lua"}},{"name":"Connect","desc":"Connects a callback to the event which is invoked when the event is fired","params":[{"name":"self","desc":"","lua_type":"Event"},{"name":"callback","desc":"The callback to invoke","lua_type":"(...any) -> ()"}],"returns":[{"desc":"An event connection that can be disconnected","lua_type":"EventConnection"}],"function_type":"static","source":{"line":209,"path":"src/Modules/Event/init.lua"}},{"name":"Once","desc":"","params":[{"name":"self","desc":"","lua_type":"Event"},{"name":"callback","desc":"The callback to invoke once","lua_type":"(...any) -> ()"}],"returns":[{"desc":"An event connection that can be disconnected","lua_type":"EventConnection"}],"function_type":"static","source":{"line":226,"path":"src/Modules/Event/init.lua"}},{"name":"Wait","desc":":::note\\nIf the timeout elapses, the coroutine resumes with no return values\\n:::","params":[{"name":"self","desc":"","lua_type":"Event"},{"name":"timeout","desc":"Optional timeout in seconds","lua_type":"number?"}],"returns":[{"desc":"The values passed when the event is fired","lua_type":"...any"}],"function_type":"static","source":{"line":247,"path":"src/Modules/Event/init.lua"}},{"name":"Fire","desc":"Fires the event with the given arguments","params":[{"name":"self","desc":"","lua_type":"Event"},{"name":"...","desc":"Values to pass to the event\'s callbacks","lua_type":"any"}],"returns":[],"function_type":"static","source":{"line":278,"path":"src/Modules/Event/init.lua"}},{"name":"DisconnectAll","desc":"Disconnects all connections from the event","params":[{"name":"self","desc":"","lua_type":"Event"}],"returns":[],"function_type":"static","source":{"line":296,"path":"src/Modules/Event/init.lua"}}],"properties":[{"name":"className","desc":"Static property that defines the class name of the `Event` object","lua_type":"string","tags":["Static"],"source":{"line":153,"path":"src/Modules/Event/init.lua"}}],"types":[{"name":"Self","desc":"","lua_type":"Event","source":{"line":26,"path":"src/Modules/Event/init.lua"}},{"name":"EventConnection","desc":"An interface that represents a connection to an event\\n\\nThis `EventConnection` object can be used to disconnect\\nthe callback from the event\\n\\n```lua\\nprint(connection:IsConnected()) -- true\\nconnection:Disconnect()\\nprint(connection:IsConnected()) -- false\\n```","fields":[{"name":"Disconnect","lua_type":"() -> ()","desc":""},{"name":"IsConnected","lua_type":"() -> boolean","desc":""}],"source":{"line":45,"path":"src/Modules/Event/init.lua"}}],"name":"Event","desc":"A signal implementation using a linked list to store callbacks\\n\\nThis behaves similarly to `RBXScriptSignal`:\\n- Argument types are not encoded into the signal\\n- Fire expects `...any` and callbacks receive `...any`\\n- Type safety is enforced by convention (consumer-side annotation) and documentation\\n\\n:::note\\nTables are passed by reference, so modifying a table passed through a callback will affect the original table. This\\nis distinguished from Roblox\'s `RBXScriptSignal`, which passes tables by value using deep copies\\n:::\\n\\n```lua\\nlocal event = Event.new()\\nevent:Connect(function(stringValue: string, numberValue: number)\\n\\tprint(\\"The event fired and passed the values:\\", stringValue, numberValue)\\nend)\\nevent:Fire(\\"Hello, world!\\", 42)\\nevent:Destroy()\\n```","source":{"line":178,"path":"src/Modules/Event/init.lua"}}')}}]);
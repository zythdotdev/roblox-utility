"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[866],{18388:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new `Bag` object","params":[],"returns":[{"desc":"The `Bag` object","lua_type":"Bag"}],"function_type":"static","tags":["Static"],"source":{"line":118,"path":"src/Modules/Bag/init.luau"}},{"name":"Destroy","desc":"Deconstructs the `Bag` object and disposes of all objects within it","params":[{"name":"self","desc":"","lua_type":"Bag"}],"returns":[],"function_type":"static","source":{"line":131,"path":"src/Modules/Bag/init.luau"}},{"name":"Add","desc":"Adds an `Item` reference to the `Bag`. When the bags contents are disposed of or the bag is destroyed the item\'s Dispose method will be invoked and the reference\\nto the item will be removed from the bag\\n\\n| Type | Dispose Method |\\n| ---- | ------- |\\n| `Instance` | `object:Destroy()` |\\n| `RBXScriptConnection` | `object:Disconnect()` |\\n| `function` | `object()` |\\n| `thread` | `task.cancel(object)` |\\n| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |\\n| `table` with `disposeMethod` | `object:disposeMethod()` |\\n\\n:::caution\\nAn error will be thrown if a Dispose method cannot be found for the object type that was added to the `Bag`\\n:::\\n\\n```lua\\n-- Adding a function to the `Bag` and then disposing of the bags contents will invoke the function\\nBag:Add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:Dispose()\\n\\n-- Adding a table to the `Bag` and then disposing of the bags contents will invoke the tables `Destroy`, \'Disconnect\' or their camelCased counterpart methods if they exist\\nlocal class = {\\n\\tDestroy = function(self)\\n\\t\\tprint(\\"Disposed!\\")\\n\\tend\\n}\\nBag:Add(class)\\nBag:Dispose()\\n\\n-- Adding a Roblox `Instance` to the `Bag` and then disposing of the bags contents will also destroy the `Instance`\\nlocal part = Instance.new(\\"Part\\")\\nBag:Add(part)\\nBag:Dispose()\\n\\n-- You can define a custom Dispose method on a table and pass it in as the second argument. This will be invoked when the bags contents are disposed of\\nlocal class = {\\n\\tCustomDisposeMethod = function(self)\\n\\t\\tprint(\\"Disposed!\\")\\n\\tend\\n}\\nBag:Add(class, \\"CustomDisposeMethod\\")\\nBag:Dispose()\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"item","desc":"Item to retain a reference to","lua_type":"Item"},{"name":"disposeMethod","desc":"An optional Dispose method name to invoke on the item when the bags disposed or destroyed","lua_type":"string?"}],"returns":[{"desc":"The item that was passed in","lua_type":"Item"}],"function_type":"static","source":{"line":200,"path":"src/Modules/Bag/init.luau"}},{"name":"Remove","desc":"Removes the item reference from the `Bag` and invokes its Dispose method. If the item was found and removed, `true` is returned, otherwise `false` is returned\\n\\n```lua\\nlocal func = Bag:Add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:Remove(func) -- \\"Disposed!\\" will be printed\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"item","desc":"Item to Remove from the bag","lua_type":"Item"}],"returns":[{"desc":"Whether or not the item was removed","lua_type":"boolean"}],"function_type":"static","source":{"line":235,"path":"src/Modules/Bag/init.luau"}},{"name":"Dispose","desc":"Disposes of all item references in the `Bag`. This is the same as invoking `Remove` on each object added to the `Bag`. The\\nobjects are disposed of in reverse order (LIFO - Last In, First Out), which is useful for proper cleanup of dependent resources\\n\\n```lua\\nlocal part = Instance.new(\\"Part\\")\\nlocal connection = part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend)\\nBag:Add(part)\\nBag:Add(connection)\\nBag:Dispose() -- \'connection\' is disconnected first, then \'part\' is destroyed\\n```","params":[{"name":"self","desc":"","lua_type":"Bag"}],"returns":[],"function_type":"static","source":{"line":274,"path":"src/Modules/Bag/init.luau"}},{"name":"Attach","desc":"Attaches the `Bag` object to a Roblox `Instance`. Invoking this method will detach the `Bag` from any previously attached `Instance`. When\\nthe attached instance is removed from the game (its parent or ancestor\'s parent is set to `nil`), the Bag will automatically destroy\\nitself. It\'s important that any references to the bag are still released when it\'s no longer being used\\n\\n:::caution\\nAn error will be thrown if `instance` is not a descendant of the DataModel\\n:::","params":[{"name":"self","desc":"","lua_type":"Bag"},{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"static","source":{"line":301,"path":"src/Modules/Bag/init.luau"}}],"properties":[{"name":"className","desc":"Static property that defines the class name `Bag`","lua_type":"string","tags":["Static"],"source":{"line":91,"path":"src/Modules/Bag/init.luau"}}],"types":[{"name":"Self","desc":"","lua_type":"Bag","source":{"line":39,"path":"src/Modules/Bag/init.luau"}},{"name":"Item","desc":"An item that can be added to the Bag","lua_type":"Instance | RBXScriptConnection | Class | Function | thread","source":{"line":47,"path":"src/Modules/Bag/init.luau"}}],"name":"Bag","desc":"A `Bag` is used to retain object references that need to be disposed of at some point in the future. When the bag is destroyed, all\\nobjects within the bag are also disposed of\\n\\n```lua\\nlocal bag = Bag.new()\\nlocal part = Instance.new(\\"Part\\")\\nbag:Add(part)\\nbag:Add(part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend))\\nbag:Destroy() -- \'part\' is destroyed and the \'Touched\' connection is disconnected\\n```","source":{"line":108,"path":"src/Modules/Bag/init.luau"}}')}}]);